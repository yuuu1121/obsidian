---
date: 2025-02-26
status: Permanent
tags: 
  - Study/OpenCV
aliases: 
keywords: 
related notes: 
reference: 
author: 
url: 
dg-publish: false
---

```python
# 0420.py
import cv2
import numpy as np

src = cv2.imread('./data/lena.jpg', cv2.IMREAD_GRAYSCALE)

minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(src)
print('src:', minVal, maxVal, minLoc, maxLoc)

dst = cv2.normalize(src, None, 100, 200, cv2.NORM_MINMAX)
minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(dst)
print('dst:', minVal, maxVal, minLoc, maxLoc)

cv2.imshow('dst', dst)
cv2.waitKey()
cv2.destroyAllWindows()
```

```output
src: 18.0 248.0 (265, 198) (116, 273)
dst: 100.0 200.0 (265, 198) (116, 273)
```
![[3_Archive/1_Attachments/675d7fc5af9bc617825ced02843f61f4_MD5.jpeg|300]]
- minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(src) :
	- src의 최소값, 최대값, 최소값 위치, 최대값 위치 반환.
- dst = cv2.normalize(src, None, 100, 200, cv2.NORM_MINMAX) :
	- src의 최소/최대값 범위 [18.0 248.0]을 범위 [100, 200]을 dst에 정규화.
	- dst = None은 결과 영상을 새로 생성.

```
# 0421.py
import cv2
import numpy as np
import time

dst = np.full((512,512,3), (255, 255, 255), dtype= np.uint8)
nPoints = 100
pts = np.zeros((1, nPoints, 2), dtype=np.uint16)

cv2.setRNGSeed(int(time.time()))
cv2.randu(pts, (0, 0), (512, 512))

# draw points
for k in range(nPoints):
	x, y = pts[0, k][:] # pts[0, k, :]
	cv2.circle(dst,(x,y),radius=5,color=(0,0,255),thickness=-1)

cv2.imshow('dst', dst)
cv2.waitKey()
cv2.destroyAllWindows()
```
![[3_Archive/1_Attachments/b699ef3ca0efab724c82e2e59d961f45_MD5.jpeg|300]]
- pts = np.zeros((1, nPoints, 2), dtype=np.uint16) :
	- 1개의 그룹, 100개의 점, (x,y)좌표, 16bit 정수
	- pts = [[[ 0 0] 
		      [ 0 0] 
		      [ 0 0] 
		      ... 
		      [ 0 0]]]

- cv2.setRNGSeed(int(time.time())) : 
	- 난수 생성 초기화.
	- 초기화하지 않으면 항상 같은 난수열 생성.
- x, y = pts[0, k][:] # pts[0, k, :] :
	- k번째의 (x,y)좌표
	- [:] : 배열의 모든 요소를 선택하는 슬라이싱 연산.

```python
# 0422.py
import cv2
import numpy as np
import time

dst = np.full((512,512,3), (255, 255, 255), dtype= np.uint8)
nPoints = 100
pts = np.zeros((1, nPoints, 2), dtype=np.uint16)
  
cv2.setRNGSeed(int(time.time()))
cv2.randn(pts, mean=(256, 256), stddev=(50, 50))
# draw points
for k in range(nPoints):
	x, y = pts[0][k, :] # pts[0, k, :]
		cv2.circle(dst,(x,y),radius=5,color=(0,0,255),thickness=-1)

cv2.imshow('dst', dst)
cv2.waitKey()
cv2.destroyAllWindows()
```
![[3_Archive/1_Attachments/afd5dd3b37fde28d0bc4900e38de2360_MD5.jpeg|300]]
- cv2.randn(pts, mean=(256, 256), stddev=(50, 50)):
	- 1xnPoints이고 2-채널인 pts 배열에 mean = (256,256), stddev = (50,50)인 정규분포 난수 생성
	- stddev : 표준편차
	- 

```python
# 0423.py
import cv2
import numpy as np

X = np.array([[0, 0, 0,100,100,150, -100,-150],
			  [0,50,-50, 0, 30,100, -20,-100]], dtype=np.float64)
X = X.transpose() # X = X.T

cov, mean = cv2.calcCovarMatrix(X, mean=None, flags = cv2.COVAR_NORMAL + cv2.COVAR_ROWS)
print('mean=', mean)
print('cov=', cov)

ret, icov = cv2.invert(cov)
print('icov=',icov)

v1 = np.array([[0],[0]] , dtype=np.float64)
v2 = np.array([[0],[50]], dtype=np.float64)

dist = cv2.Mahalanobis(v1, v2, icov)
print('dist = ', dist)

cv2.waitKey()
cv2.destroyAllWindows()
```

```output
mean= [[12.5   1.25]]
cov= [[73750.  34875. ]
	  [34875.  26287.5]]
icov= [[ 3.63872307e-05 -4.82740722e-05]
	   [-4.82740722e-05  1.02084955e-04]]
dist =  0.5051854992128457
```
- ![[3_Archive/1_Attachments/48b9f23cf9367cd1b100163d74b1f6b8_MD5.jpeg|200]]
- cov, mean = cv2.calcCovarMatrix(X, mean=None, flags = cv2.COVAR_NORMAL + cv2.COVAR_ROWS) :
	- cv2.COVAR_NORMAL : 일반적인 공분산 행렬 계산.
	- cv2.COVAR_ROWS : 각 행을 개별 샘플로 간주.
	- mean=None : 평균 자동 계산.
- ret, icov = cv2.invert(cov) : 역행렬이 존재하면 1, 존재하지 않으면 0 반환.
- [[cv2.Mahalanobis()]] : 두 벡터 v1, v2 사이의 통계적 거리.

```python
# 0424.py
import cv2
import numpy as np

X = np.array([[0, 0, 0,100,100,150, -100,-150],
			  [0,50,-50, 0, 30,100, -20,-100]], dtype=np.float64)
X = X.transpose() # X = X.T

cov, mean = cv2.calcCovarMatrix(X, mean=None, flags=cv2.COVAR_NORMAL+cv2.COVAR_ROWS)
ret, icov = cv2.invert(cov)

dst = np.full((512,512,3), (255, 255, 255), dtype= np.uint8)
rows, cols, channel = dst.shape
centerX = cols//2
centerY = rows//2

v2 = np.zeros((1,2), dtype=np.float64)
FLIP_Y = lambda y: rows - 1 - y

# draw Mahalanobis distance
for y in range(rows):
	for x in range(cols):
		v2[0,0] = x - centerX
		v2[0,1] = FLIP_Y(y) - centerY # y-축 뒤집기
		dist = cv2.Mahalanobis(mean, v2, icov)
		if dist < 0.1:
			dst[y, x] = [50, 50, 50]
		elif dist < 0.3:		
			dst[y, x] = [100, 100, 100]		
		elif dist < 0.8:		
			dst[y, x] = [200, 200, 200]	
		else:
			dst[y, x] = [250, 250, 250]

for k in range(X.shape[0]):
	x, y = X[k,:]	
	cx = int(x+centerX)	
	cy = int(y+centerY)	
	cy = FLIP_Y(cy)	
	cv2.circle(dst,(cx,cy),radius=5,color=(0,0,255),thickness=-1)

# draw X, Y-axes
cv2.line(dst, (0, 256), (cols-1, 256), (0, 0, 0))
cv2.line(dst, (256,0), (256,rows), (0, 0, 0))

# calculate eigen vectors
ret, eVals, eVects = cv2.eigen(cov)
print('eVals=', eVals)
print('eVects=', eVects)
  
def ptsEigenVector(eVal, eVect):
	## global mX, centerX, centerY
	scale = np.sqrt(eVal) # eVal[0]
	x1 = scale*eVect[0]
	y1 = scale*eVect[1]
	x2, y2 = -x1, -y1 # 대칭

	x1 += mean[0,0] + centerX
	y1 += mean[0,1] + centerY	
	x2 += mean[0,0] + centerX	
	y2 += mean[0,1] + centerY	
	y1 = FLIP_Y(y1)	
	y2 = FLIP_Y(y2)	
	return int(x1), int(y1), int(x2), int(y2)

# draw eVects[0]
x1, y1, x2, y2 = ptsEigenVector(eVals[0], eVects[0])
cv2.line(dst, (x1, y1), (x2, y2), (255, 0, 0), 2)

# draw eVects[1]
x1, y1, x2, y2 = ptsEigenVector(eVals[1], eVects[1])
cv2.line(dst, (x1, y1), (x2, y2), (255, 0, 0), 2)

cv2.imshow('dst', dst)
cv2.waitKey()
cv2.destroyAllWindows()
```