---
date: 2025-02-26
status: Permanent
tags: 
  - Study/OpenCV
aliases: 
keywords: 
related notes: 
reference: 
author: 
url: 
dg-publish: false
---

```python
# 0420.py
import cv2
import numpy as np

src = cv2.imread('./data/lena.jpg', cv2.IMREAD_GRAYSCALE)

minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(src)
print('src:', minVal, maxVal, minLoc, maxLoc)

dst = cv2.normalize(src, None, 100, 200, cv2.NORM_MINMAX)
minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(dst)
print('dst:', minVal, maxVal, minLoc, maxLoc)

cv2.imshow('dst', dst)
cv2.waitKey()
cv2.destroyAllWindows()
```

```output
src: 18.0 248.0 (265, 198) (116, 273)
dst: 100.0 200.0 (265, 198) (116, 273)
```
![[3_Archive/1_Attachments/675d7fc5af9bc617825ced02843f61f4_MD5.jpeg|300]]
- minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(src) :
	- src의 최소값, 최대값, 최소값 위치, 최대값 위치 반환.
- dst = cv2.normalize(src, None, 100, 200, cv2.NORM_MINMAX) :
	- src의 최소/최대값 범위 [18.0 248.0]을 범위 [100, 200]을 dst에 정규화.
	- dst = None은 결과 영상을 새로 생성.

```
# 0421.py
import cv2
import numpy as np
import time

dst = np.full((512,512,3), (255, 255, 255), dtype= np.uint8)
nPoints = 100
pts = np.zeros((1, nPoints, 2), dtype=np.uint16)

cv2.setRNGSeed(int(time.time()))
cv2.randu(pts, (0, 0), (512, 512))

# draw points
for k in range(nPoints):
	x, y = pts[0, k][:] # pts[0, k, :]
	cv2.circle(dst,(x,y),radius=5,color=(0,0,255),thickness=-1)

cv2.imshow('dst', dst)
cv2.waitKey()
cv2.destroyAllWindows()
```
![[3_Archive/1_Attachments/b699ef3ca0efab724c82e2e59d961f45_MD5.jpeg|300]]
- pts = np.zeros((1, nPoints, 2), dtype=np.uint16) :
	- 1개의 그룹, 100개의 점, (x,y)좌표, 16bit 정수
	- pts = [[[ 0 0] 
		      [ 0 0] 
		      [ 0 0] 
		      ... 
		      [ 0 0]]]

- cv2.setRNGSeed(int(time.time())) : 
	- 난수 생성 초기화.
	- 초기화하지 않으면 항상 같은 난수열 생성.
- x, y = pts[0, k][:] # pts[0, k, :] :
	- k번째의 (x,y)좌표
	- [:] : 배열의 모든 요소를 선택하는 슬라이싱 연산.

```python
# 0422.py
import cv2
import numpy as np
import time

dst = np.full((512,512,3), (255, 255, 255), dtype= np.uint8)
nPoints = 100
pts = np.zeros((1, nPoints, 2), dtype=np.uint16)
  
cv2.setRNGSeed(int(time.time()))
cv2.randn(pts, mean=(256, 256), stddev=(50, 50))
# draw points
for k in range(nPoints):
	x, y = pts[0][k, :] # pts[0, k, :]
		cv2.circle(dst,(x,y),radius=5,color=(0,0,255),thickness=-1)

cv2.imshow('dst', dst)
cv2.waitKey()
cv2.destroyAllWindows()
```
![[3_Archive/1_Attachments/afd5dd3b37fde28d0bc4900e38de2360_MD5.jpeg|300]]
- cv2.randn(pts, mean=(256, 256), stddev=(50, 50)):
	- 1xnPoints이고 2-채널인 pts 배열에 mean = (256,256), stddev = (50,50)인 정규분포 난수 생성
	- stddev : 표준편차
	- 

```python
# 0423.py
import cv2
import numpy as np

X = np.array([[0, 0, 0,100,100,150, -100,-150],
			  [0,50,-50, 0, 30,100, -20,-100]], dtype=np.float64)
X = X.transpose() # X = X.T

cov, mean = cv2.calcCovarMatrix(X, mean=None, flags = cv2.COVAR_NORMAL + cv2.COVAR_ROWS)
print('mean=', mean)
print('cov=', cov)

ret, icov = cv2.invert(cov)
print('icov=',icov)

v1 = np.array([[0],[0]] , dtype=np.float64)
v2 = np.array([[0],[50]], dtype=np.float64)

dist = cv2.Mahalanobis(v1, v2, icov)
print('dist = ', dist)

cv2.waitKey()
cv2.destroyAllWindows()
```

```output
mean= [[12.5   1.25]]
cov= [[73750.  34875. ]
	  [34875.  26287.5]]
icov= [[ 3.63872307e-05 -4.82740722e-05]
	   [-4.82740722e-05  1.02084955e-04]]
dist =  0.5051854992128457
```
- ![[3_Archive/1_Attachments/48b9f23cf9367cd1b100163d74b1f6b8_MD5.jpeg|200]]
- cov, mean = cv2.calcCovarMatrix(X, mean=None, flags = cv2.COVAR_NORMAL + cv2.COVAR_ROWS) :
	- cv2.COVAR_NORMAL : 일반적인 공분산 행렬 계산.
	- cv2.COVAR_ROWS : 각 행을 개별 샘플로 간주.
	- mean=None : 평균 자동 계산.